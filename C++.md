# 关键词

## const

### 作用

-   便于类型检查

-   可以保护被修饰的东西

-   可以方便的进行参数调整和修改

-   可以进行函数重载

-   **可以节省空间，避免不必要的内存分配**

    const定义常量从汇编的角度，只是给出了对应的内存地址，而不是像define 一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而define定义的常量在内存中有若干个拷贝

-   **提高效率**

    编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储和读内存的操作，使得它的效率很高

### 修饰普通变量

定义为常量，不允许其值被修改

### 修饰指针变量

-   修饰指针指向的内容，则内容为不可变量

    ```c++
    const T *ptr = val
    ```

    

-   修饰指针，则指针为不可变量

    ```C++
    T *const ptr = val
    ```

    

-   修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量

    ```c++
    const T *const ptr = val
    ```

    

### 修饰参数传递

-   值传递的 const 修饰传递

    **一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值**

    ```C++
    void func(const T x)
    ```

-   const 参数为指针

    可以防止指针被意外篡改

    ```C++
    void func(const T *ptr)
    ```

    

-   const 外加引用传递

    **需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间**

    ```
    void func(const T &x)
    ```

### 修饰函数返回值

-   修饰内置类型的返回值

    **修饰与不修饰返回值作用一样**

-   修饰自定义类型的作为返回值

    **此时返回的值不能作为左值使用，既不能被赋值，也不能被修改**

-   修饰返回的指针或者引用

    是否返回一个指向 const 的指针，取决于我们想让用户干什么

### 修饰类成员函数

**其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数**

**const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例**

```C++
void func() const {}
```

## static 

### 作用

-   延长局部变量的生命周期
-   限制全局变量的链接性为内部
-   限制函数的链接性为内部
-   阻止数据被释放
-   保证单一实例化

### 修饰局部变量

一般情况下，局部变量在程序中是存放在栈区的，并且局部变量的生命周期在包含语句块执行结束时就结束了。但是如果用static关键字修饰的话，该变量就会存放在静态数据区，其生命周期会一直延续到整个程序执行结束。但是要注意的是，虽然static在局部变量进行修饰之后，其声明周期以及存储方式发生了变化，但是其作用域没有改变，还是限制在其语句块

### 修饰全局变量

一般情况下，全局变量既可以在本文件中被访问到，也可以在同一个工程中的其他源文件被访问到（添加extern进行声明即可）。但用static对全局变量进行修饰后改变了其作用域范围，有原来的整个工程可见变成了本文件可见

### 修饰函数

用static修饰函数，情况和修饰全局变量类似，也是改变了函数的作用域

### 修饰类

如果用static修饰类中的某个函数，则表示该函数属于一个类而不是属于此类的任何特定对象；如果用static修饰类中的某个变量，则表示该变量属于一个类而不是属于此类的任何特定对象，整个程序的存储空间中只存在一个副本，可以通过类和对象去调用这个变量（注意，静态非常量数据成员，其只能在类外定义和初始化，在类内只是声明而已）	

### 函数体内、类中、模块内的static

-   函数体内static变量的作用范围是该函数体，不同于auto变量，该变量的内存只分配一次，因此其值在下次调用时仍维持上次的值
-   在模块内的static全局变量可以被模块内的所有函数访问，但是不能被其他函数访问
-   在模块内的static函数只可被这⼀模块内的其它函数调⽤，这个函数的使⽤范围被限制在声明它的模块内；
-   在类中的static成员变量属于整个类所共享，对类的所有对象只有一份拷贝
-   在类中的static成员函数属于整个类所共有，这个函数不接受this指针，因而只能访问类内的static成员变量
-   static类对象必须在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化
-   由于static修饰的[类成员](https://so.csdn.net/so/search?q=类成员&spm=1001.2101.3001.7020)属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针，正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问static修饰的类成员
-   static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义。静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr指针是通过this指针调用的，所以不能为virtual。虚函数的调⽤关系，this->vptr->ctable->virtual function。

## mutable

**mutable**修饰的变量，将永远处于可变的状态

## volatile

修饰的类型变量可能被某些编译器等未知的因素更改，因此阻止编译器对该变量进行优化，从而可以提供对特殊地址的稳定访问



# 类的关系

关系强弱关系：泛化 = 实现 < 组合 < 聚合 < 关联 < 依赖

-   泛化

    是一种继承关系，表示一般与特殊的关系，它指定了[子类](https://so.csdn.net/so/search?q=子类&spm=1001.2101.3001.7020)如何特化父类的所有特征和行为。

-   实现

    是一种类与接口的关系，表示类是接口所有特征和行为的实现.

-   关联

    是一种拥有的关系，它使一个类知道另一个类的属性和方法

-   聚合

    是整体与部分的关系，且部分可以离开整体而单独存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。

-   组合

    是整体与部分的关系，但部分不能离开整体而单独存在

-   依赖

    是一种使用的关系，即一个类的实现需要另一个类的协助

# STL

## 顺序性容器

### vector

-   扩容机制

    **扩容系数一般选择1.5或者2，具体看标准库的实现者决定**

    使用k=2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和：

    $c\sum_{i=0}^n=c(2^{n+1}-1)<c2^{n+1}$

    也就是说，之前分配的内存空间不可能被使用。这样对缓存并不友好

    **最好把增长因子设为1<k<2**

    当k=1.5之后，在几次扩容之后还可以重用之前的内存空间（能move过去）

### deque

### list

## 关联容器

-   map
-   set

## 容器适配器

-   queue
-   stack

# JSON





# C++11

## 智能指针

在C++中，动态内存的管理是通过一对运算符来完成的：new，在动态内存中为对象分配空间并返回一个指向该对象的指针，可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

动态内存的使用很容易出问题，因为确保在正确的时间释放内存是极其困难的。有时会忘记释放内存，在这种情况下会产生内存泄露；有时在尚有指针引用内存的情况下就释放了它，在这种情况下就会产生引用非法内存的指针。

为了更容易(同时也更安全)地使用动态内存，C++11标准库提供了两种智能指针(smart pointer)类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指的对象。C++11标准库提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则"独占"所指向的对象。C++11标准库还定义了一个名为weak_ptr的辅助类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。智能指针是模板类而不是指针。类似vector，智能指针也是模板，当创建一个智能指针时，必须提供额外的信息即指针可以指向的类型。默认初始化的智能指针中保存着一个空指针。智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空。

智能指针实质就是重载了->和*操作符的类，由类来实现对内存的管理，确保即使有异常产生，也可以通过智能指针类的析构函数完成内存的释放。

​     shared_ptr的类型转换不能使用一般的static_cast，这种方式进行的转换会导致转换后的指针无法再被shared_ptr对象正确的管理。应该使用专门用于shared_ptr类型转换的 static_pointer_cast<T>() , const_pointer_cast<T>() 和dynamic_pointer_cast<T>()。

​     使用shared_ptr避免了手动使用delete来释放由new申请的资源，标准库也引入了make_shared函数来创建一个shared_ptr对象，使用shared_ptr和make_shared，你的代码里就可以使new和delete消失，同时又不必担心内存的泄露。shared_ptr是一个模板类。

​     C++开发处理内存泄漏最有效的办法就是使用智能指针，使用智能指针就不会担心内存泄露的问题了，因为智能指针可以自动删除分配的内存。

智能指针是指向动态分配(堆)对象指针，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露。它的一种通用实现技术是使用引用计数。每次使用它，内部的引用计数加1，每次析构一次，内部引用计数减1，减为0时，删除所指向的堆内存。

每一个shared_ptr的拷贝都指向相同的内存。在最后一个shared_ptr析构的时候, 内存才会被释放。

可以通过构造函数、赋值函数或者make_shared函数初始化智能指针。

shared_ptr基于”引用计数”模型实现，多个shared_ptr可指向同一个动态对象，并维护一个共享的引用计数器，记录了引用同一对象的shared_ptr实例的数量。当最后一个指向动态对象的shared_ptr销毁时，会自动销毁其所指对象(通过delete操作符)。

shared_ptr的默认能力是管理动态内存，但支持自定义的Deleter以实现个性化的资源释放动作。

最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。当要用make_shared时，必须指定想要创建的对象的类型，定义方式与模板类相同。在函数名之后跟一个尖括号，在其中给出类型。例如，调用make_shared<string>时传递的参数必须与string的某个构造函数相匹配。如果不传递任何参数，对象就会进行值初始化。

通常用auto定义一个对象来保存make_shared的结果。

当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其它shared_ptr指向相同的对象。

可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数(reference count)。无论何时拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。当给shared_ptr赋予一个新值或是shared_ptr被销毁(例如一个局部的shared_ptr离开其作用域)时，计数器就会递减。一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。

当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过另一个特殊的成员函数析构函数(destructor)来完成销毁工作的。类似于构造函数，每个类都有一个析构函数。就像构造函数控制初始化一样，析构函数控制此类型的对象销毁时做什么操作。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。

如果将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。

使用shared_ptr注意事项：

(1)、不要把一个原生指针给多个shared_ptr管理；

(2)、不要把this指针给shared_ptr；

(3)、不要在函数实参里创建shared_ptr；

(4)、不要不加思考地把指针替换为shared_ptr来防止内存泄漏，shared_ptr并不是万能的，而且使用它们的话也是需要一定的开销的；

(5)、环状的链式结构shared_ptr将会导致内存泄漏(可以结合weak_ptr来解决)；

(6)、共享拥有权的对象一般比限定作用域的对象生存更久，从而将导致更高的平均资源使用时间；

(7)、在多线程环境中使用共享指针的代价非常大，这是因为你需要避免关于引用计数的数据竞争；

(8)、共享对象的析构器不会在预期的时间执行；

(9)、不使用相同的内置指针值初始化(或reset)多个智能指针；

(10)、不delete get()返回的指针；

(11)、不使用get()初始化或reset另一个智能指针；

(12)、如果使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了；

(13)、如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。	 
