# 最大子矩阵面积

## 题面

给定一个大小为n*m的01矩阵，求最大的只包含1的子矩阵面积

$1\leq n,m\leq 1000$

## 解法

其实是1维的拓展，如果只有1维，那么我们可以通过单调栈来求出，每个求出每个高度的1的不低于该高度的左右边界。二维我们可以枚举另一维，然后就变回1维的情况，只是每个1的高度需要dp一下。

## Code

```C++
#include<bits/stdc++.h>
signed main() {
    int n, m; std::cin >> n >> m;
    std::vector<std::vector<char>> a(n, std::vector<char>(m));
    for (auto &v: a)
        for (auto &u: v)
            std::cin >> u;
    int ans = 0;
    std::vector<std::vector<int>> h(2, std::vector<int>(m, 0));
    std::vector<int> l(m), r(m);
    std::vector<int> st;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (a[i][j] == '1') {
                h[i & 1][j] = i ? h[(i - 1) & 1][j] + 1: 1;
            } else {
                h[i & 1][j] = 0;
            }
        }
        for (int j = 0; j < m; j++) {
            for (; !st.empty() && h[i & 1][st.back()] > h[i & 1][j]; st.pop_back()) {
                r[st.back()] = j - 1;
            }
            if (a[i][j] == '1') st.push_back(j);
        }
        for (; !st.empty(); st.pop_back()) r[st.back()] = m - 1;
        for (int j = m - 1; j >= 0; j--) {
            for (; !st.empty() && h[i & 1][st.back()] > h[i & 1][j]; st.pop_back()) {
                l[st.back()] = j + 1;
            }
            if (a[i][j] == '1') st.push_back(j);
        }
        for (; !st.empty(); st.pop_back()) l[st.back()] = 0;
        for (int j = 0; j < m; j++) {
            ans = std::max(ans, h[i & 1][j] * (r[j] - l[j] + 1));
        }
    }
    std::cout << ans << '\n';
}
```

