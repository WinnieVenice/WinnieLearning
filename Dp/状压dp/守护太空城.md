# 守护太空城

https://leetcode-cn.com/problems/EJvmW4/

## 题面

各位勇者请注意，力扣太空城发布陨石雨红色预警。

太空城中的一些舱室将要受到陨石雨的冲击，这些舱室按照编号 0 ~ N 的顺序依次排列。为了阻挡陨石损毁舱室，太空城可以使用能量展开防护屏障，具体消耗如下：

选择一个舱室开启屏障，能量消耗为 2
选择相邻两个舱室开启联合屏障，能量消耗为 3
对于已开启的一个屏障，多维持一时刻，能量消耗为 1
已知陨石雨的影响范围和到达时刻，time[i] 和 position[i] 分别表示该陨石的到达时刻和冲击位置。请返回太空舱能够守护所有舱室所需要的最少能量。

注意：

同一时间，一个舱室不能被多个屏障覆盖
陨石雨仅在到达时刻对冲击位置处的舱室有影响1 <= time.length == position.length <= 500
1 <= time[i] <= 5
0 <= position[i] <= 100

## 思路

对于某个位置的舱室i，根据题目性质我们发现只会与i-1或i+1有关，不难考虑成第i个，那么只需要考虑i-1和i的状态

对于某个舱室i的被冲击的时间戳，他需要开屏障，显然会跟i-1的时间戳有关，因此我们考虑对每个舱室的时间戳进行状压

由于联合屏障之间不能重叠，所以我们考虑对使用联合屏障的状态

定义状态$f(i,j):第i个舱室，第i个舱室开启联合屏障的时间戳的答案$

那么就有$f(i,j) = min_{k\cap j=\empty}\{f(i,k) + g(j)+h(t)\}$

由于联合屏障之间不能重叠，所以我们需要枚举不相交的两个状态集合

$g(j)$是当前状态开启联合屏障的最小花费

$h(t)$是要保证其他不开启联合屏障的不被冲击的最小花费，t是在j中但不在k中的状态

显然$g和h$都能通过预处理处理出来

## Code

```C++
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    int defendSpaceCity(vector<int>& t, vector<int>& p) {
        int n = *max_element(t.begin(), t.end()), m = *max_element(p.begin(), p.end());
        vector<int> bit(m + 2, 0);
        for (int i = 0; i < t.size(); i++) {
            bit[p[i]] |= 1 << (t[i] - 1);
        }
        vector<int> g(1 << n, 0), h(1 << n, 0);
        for (int i = 0; i < 1 << n; i++){
            int lb = i & -i, j = i ^ lb, lb1 = j & -j;
            g[i] = g[j] + (lb1 >> 1 == lb? 1: 3);
            h[i] = h[j] + (lb1 >> 1 == lb? 1: 2);
        }
        vector<vector<int>> f(m + 2, vector<int>(1 << n, (int)1e9));
        for (int i = 1; i <= m + 1; i++) {
            for (int j = 0; j < 1 << n; j++) {
                for (int c = ((1 << n) - 1) ^ j, k = c; k; k = (k - 1) & c) {
                    f[i][j] = min(f[i][j], f[i - 1][k] + g[j] + h[(c ^ k) & bit[i - 1]]);
                }
            }
        }
        return f[m + 1][0];
    }
};
```

