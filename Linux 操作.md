# Linux 操作

ls	显示当前目录列表

cd dir	到达目录dir

mkdir dir	创建目录dir

vim name	打开文件name

touch name	创建文件name

rm name	删除文件name

ll	查看文件及目录详情

cp [options] source dest	将source复制到dest，options是具体复制操作的选项

mv [options] source dest	将source移动到dest，options是具体移动操作的选项

*.xxx	相当于对所有.xxx后缀的对象进行操作

..	上级目录

.	当前目录

env	显示当前用户的环境变量	

export [-f/-n/-p] [name] = [val]	设置或显示环境变量name的值为val，可以新增、修改、删除环境变量。-f 代表[name]中为函数名称；-n 删除指定的变量（实际上并未删除，只是不输出到后续值令的执行环境中）；-p 列出所有shell赋予程序的环境变量。这种方式事实上不会真的修改，只是会改变当前终端的后续执行环境。

$name	获取变量name或环境变量name的值

pwd	（print work directory）用于显示工作目录，得到当前所在目录的绝对路径名称

echo xxx	将xxx打印显示出来，xxx可以是变量

source filename	在当前bash环境下读取并执行filename中的命令（也可以使用 . filename ）

cd ~	家目录

## 编辑操作

shift + g	下拉到最下面

o	插入

wq	保存并退出



# GCC操作

## gcc/g++编译选项

-E	预处理指定源文件，不进行编译

-S	编译指定源文件，但是不进行汇编

-c	编译、汇编指定源文件，但是不进行链接

-o [file1] [file2] / [file2] -o [file1]	将文件file2编译成可执行文件file1

-I(大写的i) dir	指定include包含文件的搜索目录dir

-g	在编译的时候，生成调试信息，该程序可以被调试器调试

-D name	编译的时候指定宏name

-w	不生成任何警告信息

-Wall	生成所有警告信息

-On	“吸氧”，n的取值范围：0~3。编译器的优化选项的4个级别：-O0没有优化，-O1为缺省值（默认），-O3优化级别最高 

-l(小写的L)	在程序编译的时候，指定使用的库

-L	指定编译的时候，搜索库的路径

-fPIC/fpic	生成与位置无关（内存位置）的代码

-shared	生成共享目标文件，通常用在建立共享库时

-std	指定c语言，如：-std=99，gcc默认的方言是GNU C

# 库

## 工作原理

静态库：gcc进行链接时，会把静态库中代码打包到可执行程序中

动态库：gcc进行链接时，动态库的代码不会被打包到可执行程序中

程序启动之后，动态库会被动态加载到内存中，通过ldd（list dynamic dependencies）命令检查动态库依赖关系

Linux定位共享库文件：当系统加载可执行代码时，能够知道其所依赖的库的文件，但是还需要知道绝对路径。此时需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的DT_RPATH段->环境变量LD_LIBRARY_PATH->/etc/ld.so.cache文件列表->/lib/,/usr/lib目录找到库文件后将其载入内存（不建议使用最后一种方法，因为预置了系统的库文件）

### 修改环境变量的方法

不同目录之间用 : 分隔开

方法一（终端级）：修改当前bash（终端）的环境变量，直接在当前bash中export环境变量

方法二（用户级）：在用户根目录的隐藏文件.bashrc中修改环境变量，在根目录的.bashrc中export环境变量，然后source生效export指令

方法三（系统级）：在系统/etc/profile文件中修改环境变量，export然后再source

### 修改/etc/ld.so.cache

无法直接修改，间接修改通过/etc/ld.so.conf，直接在里面添加环境变量的路径，然后ldconfig。（都在sudo下执行）

## 静态库和动态库的区别

静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而实程序在运行时由系统动态加载到内存中供程序调用。

具体而言：

在链接阶段，静态库将被需要的代码链接进去，而动态库只会将一些动态库的信息（比如：名称、地址）链接进去，当程序运行需要的时候再寻找动态库的文件，并把动态库加载到内存中，这样才能使用动态库中的代码。

## 库的好处

1、代码保密；

2、方便部署和分发

## 静态库

### 命名规则

Linux：libxxx.a	lib固定前缀，xxx库的名字，.a固定后缀

Windows：libxxx.lib	lib固定前缀，xxx库额名字，.lib固定后缀

### 静态库的制作

步骤一：gcc获得.o文件，将库文件编译，要在头文件下，或者指定头文件

gcc/g++ -c

步骤二：将.o文件打包，使用ar工具（archive)	

ar rcs libxxx.a xxx.o xxx.o	

r - 将文件插入备存文件中 

c - 建立备存文件 

s - 索引

### 静态库的使用

在程序的源代码中inclue 头文件和调用里面的函数/变量

编译的时候要指定头文件目录和库文件目录、

### 静态库的优缺点

- 优点

  静态库被打包到应用程序中加载速度快

  发布程序无需提供静态库，移植方便

- 缺点

  消耗系统资源，浪费内存

  更新、部署、发布麻烦

  

## 动态库（共享库）

### 命名规则

Linux：libxxx.so	lib：固定前缀	xxx：库的名字	.so：固定后缀	在linux下是一个可执行文件

Windows：libxxx.dll

### 动态库的制作

步骤一：gcc/g++ 编译得到.o文件，得到和位置无关的代码	

gcc -c -fpic/-fPIC xxx.c xxx.c

步骤二：gcc得到动态库

gcc -shared xxx.o xxx.o -o libxxx.so

### 动态库的使用

在程序的源代码中inclue 头文件和调用里面的函数/变量

编译的时候要指定头文件目录和库文件目录

### 动态库优缺点

- 优点

  可以实现进程间资源共享（共享库）

  更新、部署、发布简单

  可以控制何时加载动态库

- 缺点

  加载速度比静态库慢

  发布程序时需要提供依赖的动态库

