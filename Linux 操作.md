# 

Linux 操作

## 基础指令

-   (指令) &

    在后台运行

-   ls	

    显示当前目录列表

-   cd dir	

    到达目录dir

-   mkdir dir	

    创建目录dir

-   vim name 

    打开文件name

-   set nu 

    显示行号（在文件内使用）

-   touch name	

    创建文件name

-   rm name	

    删除文件name

-   ll	

    查看文件及目录详情

-   cp [options] source dest	

    将source复制到dest，options是具体复制操作的选项

-   mv [options] source dest	

    将source移动到dest，options是具体移动操作的选项

-   *.xxx	

    相当于对所有.xxx后缀的对象进行操作

-   ..	

    上级目录

-   .	

    当前目录

-   env	

    显示当前用户的环境变量	

-   export [-f/-n/-p] [name] = [val]	

    设置或显示环境变量name的值为val，可以新增、修改、删除环境变量。-f 代表[name]中为函数名称；-n 删除指定的变量（实际上并未删除，只是不输出到后续值令的执行环境中）；-p 列出所有shell赋予程序的环境变量。这种方式事实上不会真的修改，只是会改变当前终端的后续执行环境。

-   $name	

    获取变量name或环境变量name的值

-   pwd	

    （print work directory）用于显示工作目录，得到当前所在目录的绝对路径名称

-   echo xxx	

    将xxx打印显示出来，xxx可以是变量

-   source filename	

    在当前bash环境下读取并执行filename中的命令（也可以使用 . filename ）

-   cd ~	

    家目录

## 编辑操作

shift + g	下拉到最下面

o	插入

wq	保存并退出

# GCC操作

## gcc/g++编译选项

-E	预处理指定源文件，不进行编译

-S	编译指定源文件，但是不进行汇编

-c	编译、汇编指定源文件，但是不进行链接

-o [file1] [file2] / [file2] -o [file1]	将文件file2编译成可执行文件file1

-I(大写的i) dir	指定include包含文件的搜索目录dir

-g	在编译的时候，生成调试信息，该程序可以被调试器调试

-D name	编译的时候指定宏name

-w	不生成任何警告信息

-Wall	生成所有警告信息

-On	“吸氧”，n的取值范围：0~3。编译器的优化选项的4个级别：-O0没有优化，-O1为缺省值（默认），-O3优化级别最高 

-l(小写的L)	在程序编译的时候，指定使用的库

-L	指定编译的时候，搜索库的路径

-fPIC/fpic	生成与位置无关（内存位置）的代码

-shared	生成共享目标文件，通常用在建立共享库时

-std	指定c语言，如：-std=99，gcc默认的方言是GNU C

# 库

## 工作原理

静态库：gcc进行链接时，会把静态库中代码打包到可执行程序中

动态库：gcc进行链接时，动态库的代码不会被打包到可执行程序中

程序启动之后，动态库会被动态加载到内存中，通过ldd（list dynamic dependencies）命令检查动态库依赖关系

Linux定位共享库文件：当系统加载可执行代码时，能够知道其所依赖的库的文件，但是还需要知道绝对路径。此时需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的DT_RPATH段->环境变量LD_LIBRARY_PATH->/etc/ld.so.cache文件列表->/lib/,/usr/lib目录找到库文件后将其载入内存（不建议使用最后一种方法，因为预置了系统的库文件）

### 修改环境变量的方法

不同目录之间用 : 分隔开

方法一（终端级）：修改当前bash（终端）的环境变量，直接在当前bash中export环境变量

方法二（用户级）：在用户根目录的隐藏文件.bashrc中修改环境变量，在根目录的.bashrc中export环境变量，然后source生效export指令

方法三（系统级）：在系统/etc/profile文件中修改环境变量，export然后再source

### 修改/etc/ld.so.cache

无法直接修改，间接修改通过/etc/ld.so.conf，直接在里面添加环境变量的路径，然后ldconfig。（都在sudo下执行）

## 静态库和动态库的区别

静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而实程序在运行时由系统动态加载到内存中供程序调用。

具体而言：

在链接阶段，静态库将被需要的代码链接进去，而动态库只会将一些动态库的信息（比如：名称、地址）链接进去，当程序运行需要的时候再寻找动态库的文件，并把动态库加载到内存中，这样才能使用动态库中的代码。

## 库的好处

1、代码保密；

2、方便部署和分发

## 静态库

### 命名规则

Linux：libxxx.a	lib固定前缀，xxx库的名字，.a固定后缀

Windows：libxxx.lib	lib固定前缀，xxx库额名字，.lib固定后缀

### 静态库的制作

步骤一：gcc获得.o文件，将库文件编译，要在头文件下，或者指定头文件

gcc/g++ -c

步骤二：将.o文件打包，使用ar工具（archive)	

ar rcs libxxx.a xxx.o xxx.o	

r - 将文件插入备存文件中 

c - 建立备存文件 

s - 索引

### 静态库的使用

在程序的源代码中inclue 头文件和调用里面的函数/变量

编译的时候要指定头文件目录和库文件目录、

### 静态库的优缺点

- 优点

  静态库被打包到应用程序中加载速度快

  发布程序无需提供静态库，移植方便

- 缺点

  消耗系统资源，浪费内存

  更新、部署、发布麻烦

  

## 动态库（共享库）

### 命名规则

Linux：libxxx.so	lib：固定前缀	xxx：库的名字	.so：固定后缀	在linux下是一个可执行文件

Windows：libxxx.dll

### 动态库的制作

步骤一：gcc/g++ 编译得到.o文件，得到和位置无关的代码	

gcc -c -fpic/-fPIC xxx.c xxx.c

步骤二：gcc得到动态库

gcc -shared xxx.o xxx.o -o libxxx.so

### 动态库的使用

在程序的源代码中inclue 头文件和调用里面的函数/变量

编译的时候要指定头文件目录和库文件目录

### 动态库优缺点

- 优点

  可以实现进程间资源共享（共享库）

  更新、部署、发布简单

  可以控制何时加载动态库

- 缺点

  加载速度比静态库慢

  发布程序时需要提供依赖的动态库

# Makefile

一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile文件像一个shell脚本一样，也可以执行操作系统的命令。

## 好处

自动化编译。Makefile一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说大多数IDE都要这个命令。（Visual C++ : nmake；Linux GNU：make）

## 编写

### 文件命名

makefile 或者Makefile

### 规则

-   一个Makefile文件中可以有一个或者多个规则

    目标…: 依赖…

    ​		命令(shell命令)

    ​		…

    （目标：最终要生成的文件（伪目标除外）；依赖：生成目标所需要的文件或是目标；命令：通过执行命令对依赖操作生成目标（命令前必须tab缩进））

-   其他规则一般都是为第一条规则服务

## 工作原理

-   命令在执行之前，需要检查规则中的依赖是否存在

    如果存在，执行命令

    如果不存在，向下检查其他规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令

-   检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间

    如果依赖的时间比目标的时间晚，需要重新生成目标

    如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行

## 变量

-   自定义变量

    变量名 = 变量值

-   预定义变量

    AR ：归档维护程序的名称，默认值为 ar

    CC ：C编译器的名称，默认值为 cc

    CXX ：C++编译器名称，默认值为 g++

    $自动变量(只能在规则的命令中使用)\begin{cases}\ \$@ ：目标的完整名称 \\ \$< ：第一个依赖文件的名称\\ \$^ ：所有的依赖文件 \end{cases}$

-   获取变量的值

    $(变量名)

## 模式匹配

%：通配符，匹配一个字符串

两个%匹配的是同一个字符串

## 函数

格式：

$(函数名 函数参数…)

例如：

-   $(wildcard PATTERN…)

    功能：获取指定目录下指定类型的文件列表

    参数：PATTERN指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔

    返回：得到的若干个文件的列表，文件名之间使用空格间隔

    示例：

    $(wildcard \*.c ./sub/\*.c)

    返回格式：a.c b.c c.c d.c e.c f.c

-   $(patsubst \<pattern\>, \<replacement\>,\<text\>)

    功能：查找\<text\>中的单词（单词以“空格”、“tab”或“回车””换行“分隔）是否符合模式\<pattern\>，如果匹配，则以\<replacement\>替换

    \<pattern\>可以包括通配符’%‘，表示任意长度的字符串。如果\<replacement\>中也包含‘%’，那么，\<replacement\>中的这个‘%’将是\<pattern\>中的那个%所代表的字符串。（可以用‘\’来转义，来表示真实含义的‘%’字符)

    返回：函数返回被替换过后的字符串

    示例：

    $(patsubst %.c, %.o, x.c bar.c)

    返回值格式：x.o bar.o

## 伪目标

当不需要生成目标文件时，可将目标文件变成伪目标即可

格式：

.PHONY: 目标

# GDB调试

## GDB

GDB是由GNU软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，GDB是Linux和许多类Unix系统中的标准开发环境

## 功能

1.启动程序，可以按照自定义的要求运行程序

2.可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）

3.当程序被停住时，可以检查此时程序中所发生的事

4.可以改变程序，将一个bug产生的影响修成从而测试其他bug

## 准备工作

通常，在为调试而编译时，我们会关掉编译器的优化选项（‘-o’），并打开调试选项（’-g’）。另外，

‘-wall’在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免不必要的bug。

示例：

gcc -g -Wall progam.c -o progam

‘-g’选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件

## GDB 命令

-   启动和退出

    gdb 可执行程序

    quit

-   给程序设置参数/获取设置参数

    set args 10 20

    show args

-   查看当前文件代码

    list/l (从默认位置显示)

    list/l 行号 (从指定的行显示)

    list/l 函数名 (从指定的函数显示)

-   查看非当前文件代码

    list/l 文件名：行号

    list/l 文件名：函数名

-   设置显示的行数

    show list/listsize

    set list/listsize 行数

-   gdb使用帮助

    help

-   设置断点

    b/break 行号
    b/break 函数名

    b/break 文件名：行号

    b/break 文件名：函数

-   查看断点

    i/info b/break

-   删除断点

    d/del/delete 断点编号

-   设置断点无效

    dis/disable 断点编号

-   设置断点生效

    ena/enable 断点编号

-   设置条件断点（一般用在循环的位置）

    b/break 断点编号 条件

    示例：

    b/break 10 if i == 5

-   运行GDB程序

    start（程序停在第一行）

    run（遇到断点才停）

-   继续运行，到下一个断电停

    c/continue

-   向下执行一行代码（不会进入函数体）

    n/next

-   变量操作

    p/print 变量名（打印变量值）

    ptype 变量名（打印变量类型）

-   向下单步调试（遇到函数进入函数体）

    s/step

    finish(跳出函数体)

-   自动变量操作

    display num（自动打印指定变量的值）

    i/info display 

    undisplay 编号

-   其他操作

    set var 变量名=变量值

    until（跳出循环）

## 多进程调试

gdb默认只能跟踪一个进程

-   set follow-fork-mode [parent(默认) | child]

    设置调试父进程或者子进程

-   set detach-on-fork [on(默认) | off]

    设置调试模式. on:表示调试当前进程时,其他进程继续运行; off: 其他进程被gdb挂起

-   info inferiors

    查看调试的进程

-   inferiors id

    切换当前调试的进程

-   detach inferiors id

    使进程脱离gdb调试

# C函数

## 文件属性操作函数

-   int access(const char *pathname, int mode)

    判断文件权限或文件是否存在

-   int chmod(const char *filename, int mode)

    修改文件权限

-   int chown(const char *path, uid_t owner, gid_t group)

    修改文件的所有者或者所在组

-   int truncate(const char *path, off_t length)

    缩减或拓展文件的大小

## 目录操作函数

-   int mkdir(const char *pathname, mode_t mode)

    创建目录

-   int rmdir(const char *pathname)

    删除空目录

-   int rename(const char *oldpath, const char *newpath)

    重命名目录

-   int chdir(const char *path)

    修改当前目录的当前路径

-   char *getcwd(char *buf, size_t size)

    获取当前的路径

## 目录遍历函数

-   DIR *opendir(const char *name)

    打开目录

-   struct dirent *readdir(DIR *dirp)

    读取目录

-   int closedir(DIR *dirp)

    关闭目录	

## 文件操作符相关函数

-   int dup(int oldfd)

    复制文件描述符

-   int dup2(int oldfd, int newfd)

    重定向文件描述符，即：将newfd重定向至oldfd的指向，该函数的返回值与newfd相同

-   int fcntl(int fd, int cmd, …/\*arg\*/)

    复制文件描述符

    设置/获取文件的状态标志

    cmd：该函数内定义的一些命令宏

    …：可选参数

## exec函数族

(函数族:一系列具有相同或类似功能的函数的统称)

### 作用

根据指定的文件名找到可执行文件,并用它来取代调用进程的内容.

即:在调用进程内部执行一个可执行文件.

exec函数执行成功后不会返回,因为调用进程的实体,包括代码段,数据段,堆栈都被新内容替代(用户数据区),只留下进程ID等一些表面信息保持原样.只有调用失败了,才会返回-1,从原程序的调用点接着往下执行.

-   int execl(const char *path, const char *arg, …/\*(char \*) NULL\*/)

    path:需要指定的执行的文件的路径或者名称

    arg:是可执行文件所需要的参数列表

    ​	第一个参数没什么作用,一般写可执行程序的名称

    ​	第二个参数开始就是程序执行所需要的参数列表

    ​	参数最后需要以NULL结束

    返回值:

    ​	只有调用失败才会返回-1,否则没有返回值

-   int execlp(const char *file, const char *arg, …/\*(char *) NULL\*/)

    [会到环境变量中查找指定的可执行文件,如果找到了就执行,找不到就执行不成功]

    path:需要指定的执行的文件的文件名

    arg:是可执行文件所需要的参数列表

    ​	第一个参数没什么作用,一般写可执行程序的名称

    ​	第二个参数开始就是程序执行所需要的参数列表

    ​	参数最后需要以NULL结束

    返回值:

    ​	只有调用失败才会返回-1,否则没有返回值

-   int execle(const char *path, const char *arg,…/\*(char *) NULL, char *const envp[]\*/)

-   int execv(const char *path, char *const argv[])

-   int execvp(const char *file, char *const argv[])

-   int execvpe(const char *file, char *const argv[], char *const envp[])

-   int execve(const char *filename, char *const argv[], char *const enp[])

    前6个是标准C库的,最后一个是Linux的

    l(list)	参数地址列表,以空指针结尾

    v(vector)	存有各参数地址的指针数组的地址

    p(path)	按PATH环境变量指定的目录搜索可执行文件

    e(environment)	存有环境变量字符串地址的指针数组的地址

# 进程

## 进程组

每个进程组有一个领头进程。进程组是一个或多个进程的集合，通常它们与一组作业相关联，可以接受来自同一终端的各种信号。



## 显示进程

-   ps aux / ajx

    查看进程

    a :  显示终端上的所有进程, 包括其他用户进程

    u : 显示进程的详细信息

    x : 显示没有控制终端的进程

    j : 列出与作业控制相关的信息

-   top

    实时显示进程动态

    -d 设置刷新间隔时间

-   kill 

    杀死进程

    kill [-signal] pid	杀死进程

    kill -l 列出所有信号

    kill -9 / -SIGKILL  进程ID	强制杀死进程

    killall name 根据进程名杀死进程

## 显示进程

-   pid_t getpid(void)

    获取当前进程ID

-   pid_t getppid(void)

    获取当前进程的父进程ID

## 进程创建

-   pid_t fork(void)

    创建当前子进程

    返回值: 成功:子进程中返回0,父进程返回子进程ID;失败返回-1

    失败原因:当前系统进程数达到上限(errno:EAGAIN);系统内存不足(errno:ENOMEM)
    
    通过fork()复制当前进程创建出的子进程除了pid不同外,(虚拟地址的)用户区数据和内核区都一样,具体来说(fork是写时拷贝):一开始fork完,用户区资源是共享的(共享同一个空间地址),内核区还是要独立的,但是部分内核区数据一样,只要是只读状态那么用户区资源都是共享的,只有在写入修改的情况下才会开始复制数据(分配新的内存)
    
-   父子进程的区别

    1.fork()的函数返回值不同

    ​	父进程中:>0 返回的子进程ID

    ​	子进程中:=0

    2.pcb中的一些数据不同

    ​	当前进程ID pid

    ​	当前进程的父进程ID pid

    ​	信号集

-   父子进程的共同点

    某些状态下:子进程刚被创建出来,还没执行任何写数据的操作

    ​	用户区数据一样

    ​	文件描述符表一样

    父子进程对变量的共享情况:

    ​	刚开始时,是一样的,共享的.如果修改了数据,不共享了

    ​	(读时共享(没有进行任何写的操作),写时拷贝)

## 进程退出

-   void exit(int status)

    #include<stdlib.h>

    status: 退出时的状态.父进程回收子进程时可以获取

-   void _exit(int status)

    #include<unistd.h>

![image-20220303200239408](https://raw.githubusercontent.com/WinnieVenice/PicBed/main/202203032002638.png)

## 孤儿进程

父进程结束运行,但子进程还在运行(未运行结束),这样的子进程就叫孤儿进程

每当出现一个孤儿进程时,内核就把孤儿进程的父进程设置为init, 而init进程会循环地wait()它的已经退出的子进程.当孤儿进程结束其生命周期时,init进程会回收.

孤儿进程没什么危害

## 僵尸进程

每个进程结束之后,都会释放自己地址空间中的用户区数据,内核区的PCB没有办法自己释放,需要父进程释放.

进程终止时,父进程尚未回收,子进程残留资源(PCB)存放于内核中,变成僵尸进程.

僵尸进程无法被kill -9杀死

-   危害:

    如果父进程不调用wait()或waitpid()的话,那么残留的信息将不会释放,其进程号会一直被占用,但系统的进程号是有限的,如果产生大量的僵尸进程,将因为没有可用的进程号而导致系统不能产生新的进程
    

## 进程回收

在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要指进程控制块PCB的信息（进程号、退出状态、运行时间等）。

父进程可以调用wait()或waitpid()得到它的退出状态同时彻底清除掉这个进程。

一次wait()或waitpid()调用只能清理一个子进程，清理多个子进程应使用循环。

### wait()和waitpid()异同

-   相同

    函数的功能相同

-   差异

    wait()会阻塞；waitpid()可以设置不阻塞，还可以指定等待哪个子进程结束	

### wait

pid_t wait(int *wstatus)

-   功能

    等待任意一个子进程结束，如果任意一个子进程结束了，次函数会回收子进程的资源

-   参数

    wstatus：进程退出时的状态信息，传入的是一个int型的地址，传出参数

-   返回值

    成功：返回被回收的子进程的id

    失败：-1 （所有子进程都结束了，或者调用函数失败）

-   过程：

    调用wait函数的进程会被挂起（阻塞），知道它的一个子进程退出或者收到一个不能被忽视的信号时才被唤醒

    如果没有子进程了，函数立刻返回，返回-1；如果子进程都结束了，函数也会立刻返回-1

### waitpid

pid_t waitpid(pid_t pid, int *wstatus, int options)

-   功能

    回收指定进程号的子进程，可以设置是否阻塞

-   参数

    pid：

    ​	pid > 0：某个子进程的pid

    ​	pid = 0：回收当成进程组的所有子进程

    ​	pid  = -1：回收所有的子进程，相当于wait()

    ​	pid < -1：某个进程组的组id的绝对值，回收指定进程组中的子进程

    options：设置阻塞或非阻塞

    ​	0：阻塞

    ​	WNOHANG：非阻塞（即：没有子进程会立即返回）

-   返回值

    \> 0：返回被回收的子进程id

    = 0：options = WNOHANG，表示还有子进程或者还有子进程没有退出	

    = -1：错误，或者没有子进程

### 退出信息相关宏函数

-   WIFEXITED(status) 

    非0，进程正常退出

-   WEXITSTATUS(status)

    如果宏为真，获取进程退出的状态（exit的参数）

-   WIFSIGNALED(status)

    非0，进程异常终止

-   WTERMSIG(status)

    如果宏为真，获取使进程终止的信号编号

-   WIFSTOPPED(status)

    非0，进程处于暂停状态

-   WSTOPSIG(status)

    如果宏为真，获取使进程暂停的信号编号

-   WIFCONTINUED(status)

    非0，进程暂停后已经继续运行

# 进程间通信（IPC）

## 概念

进程是一个独立的资源分配单元，不同进程（通常指用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。

但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信

## 目的

-   数据传输：一个进程需要将它的数据发送给另一个进程
-   通知时间：一个进程需要向另一个或一组进程发送消息，通知它（他们）发生了某种事情（如：进程终止时要通知父进程）
-   资源共享：多个进程之间共享同样的资源。为了做到这点，需要内核提供互斥和同步机制
-   进程控制：有些进程希望完全控制另一个进程的执行（比如debug [gdb]进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

## 方式

![image-20220314001725009](https://raw.githubusercontent.com/WinnieVenice/PicBed/main/202203140024844.png)

## 匿名管道(PIPE)

### 内容

UNIX系统IPC的最古老形式，所有的UNIX系统都支持这种通信方式

例：

统计一个目录中文件数目命令 ls | wc - l，（中间的‘|’为管道符） 为了执行该命令，shell创建了两个进程来分别执行ls和wc。

![image-20220314082224893](https://raw.githubusercontent.com/WinnieVenice/PicBed/main/202203140822953.png)

### 特点

-   管道其实时一个在内核内存中维护的缓冲器，这个缓冲器的存储能力有限，不同的操作系统大小不一定相同

-   管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作

-   一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少

-   通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的

-   在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。

-   从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多数据，在管道中无法使用lseek()来随机的访问数据

-   匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用

    ![image-20220314083951833](https://raw.githubusercontent.com/WinnieVenice/PicBed/main/202203140839883.png)

### 管道的数据结构

是个循环队列，有两个指针：一个是读指针，一个是写指针

### 匿名管道的使用

#### 创建匿名管道

-   int pipe(int pipefd[2])

    -   功能：创建一个匿名管道，用来进程间通信

    -   参数：int pipefd[2] 这个数组是一个传出参数

        ​	pipefd[0]	对应的是管道的读端

        ​	pipefd[1]	对应的是管道的写端

    -   返回值：

        ​	成功：0

        ​	失败：-1

    -   管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞

    -   注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）

#### 查看管道缓冲大小命令

-   ulimit -a

#### 查看管道缓冲大小函数

-   long fpathconf(int fd, int name)

### 匿名管道通信情况

![image-20220314094253863](https://raw.githubusercontent.com/WinnieVenice/PicBed/main/202203140942924.png)

如图第1、2种情况都会造成自己读自己写进管道的信息，所以一般都是要用第3种（通过close(对应pipefd端口)实现）

### 匿名管道的读写特点

-   所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端读取数据，那么管道种剩余的数据被读取后，再次read会返回0，就像读到文件末尾一样

-   如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数>0），而持有管道写端的进程也没有往管道中写数据，这时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次read会阻塞，直到管道中有数据可以读了才读取数据并返回

-   如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE（管道破裂），通常会导致进程异常终止

-   如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数>0），而持有管道读端的进程也没有从管道中读数据，这时候有进程向管道中写数据，那么在管道被写满的时候，再次write会阻塞，直到管道中有空位置才能再次写入数据并返回

-   总结：

    ​	读管道：

    ​		管道中有数据，read返回实际读到的字节数

    ​		管道中无数据：

    ​			写端被全部关闭，read返回0

    ​			写端没有完全关闭，read阻塞等待

    ​	写管道：

    ​		管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）

    ​		管道读端没有全部关闭：

    ​			管道已满，write阻塞

    ​			管道没有满，write将数据写入，并返回实际写入的字节数

### 设置非阻塞

通过fcntl将fd修改成非阻塞的

## 有名管道（FIFO）

### 内容

-   匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服该缺点，提出了有名管道，也叫命名管道、FIFO文件。
-   有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与FIFO的创建进程不存在亲缘关系，只要可以访问该路径，就能够彼此通过FIFO相互通信，因此，通过FIFO不想关的进程也能交换数据
-   一旦打开了FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I/O系统调用。和管道一样，FIFO也有一个输入端和读取段，并且从管道中读取数据的顺序与写入的顺序是一样的。

### FIFO与PIPE的异同

FIFO和PIPE有一些特点是相同的，不同的地方在于：

	1. FIFO在文件系统中作为一个特殊文件存在，但FIFO中的内容却存放在内存中
 	2. 当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用
 	3. FIFO有名字，不相关的进程可以通过打开有名管道进行通信

### 有名管道的使用

####  创建有名管道

-   通过命令创建有名管道

    mkfifo 名字

-   通过函数创建有名管道

    int mkfifo(const char *pathname, mode_t mode)

    -   参数：

        ​	pathname：管道名称的路径

        ​	mode：文件的权限，和open的mode是一样的，是个八进制的数

    -   返回值：

        ​	成功：0

        ​	失败：-1，并设置错误号

#### 使用

-   一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的I/O函数都可以用。
-   FIFO严格遵循先进先出，对管道及FIFO的读总是从开始处返回数据，对他们的写则把数据添加到末尾。不支持lseek()等文件定位操作

#### 注意事项

-   一个为只读而打开一个管道的进程会阻塞，直到另一个进程为只写打开管道

-   一个为只写而打开一个管道的进程会阻塞，直到另一个进程为只读打开管道

-   总结：

    ​	读管道：

    ​		管道中有数据，read返回实际读到的字节数

    ​		管道中无数据：

    ​			管道写端被全部关闭，read返回0

    ​			写端没有全部被关闭，read阻塞等待

    ​	写管道：

    ​		管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）

    ​		管道读端没有全部被关闭：

    ​			管道已经满了，write会阻塞

    ​			管道没有满，write将数据写入，并返回实际写入的字节数

## 内存映射

### 内容

内存映射是将磁盘文件的数据映射到内存（动态库加载的区域），用户通过修改内存就能修改磁盘文件

![image-20220314153744018](https://raw.githubusercontent.com/WinnieVenice/PicBed/main/202203141537077.png)

### 相关系统调用

-   void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)

    -   功能：将一个文件或者设备的数据映射到内存中

    -   参数：

        ​	void *addr：NULL，由内核指定

        ​	length：要映射的数据的长度，非0，（建议使用文件的长度）

        ​		获取文件的长度：stat lseek

        ​	prot：对申请的内存映射区的操作权限

        ​		PROT_EXEC：可执行权限

        ​		PROT_READ：读权限（要操作映射区，必须要有读权限）

        ​		PROT_WRITE：写权限	（一般还要有读权限）

        ​		PROT_NONE：没有权限

        ​	flags：

        ​		MAP_SHARED：映射区的数据会自动和磁盘文件进行同步，进程间通信必须要设置该选项

        ​		MAP_PRIVATE：不同步，内存映射区的数据改变了，不会修改原来的文件，会重新创建一个新的文件（copy on write)

        ​	fd：需要映射的那个文件的文件描述符

        ​		通过open得到，open的是一个磁盘文件

        ​		（注意：文件大小不能为0， open指定的权限不能和prot参数有冲突）

        ​	offset：要映射数据在文件中的偏移量，一般不用（必须指定的是4k的整数倍，0表示不偏移）

    -   返回值：

        ​	成功：返回创建的内存的首地址

        ​	失败：返回一个宏MAP_FAILED（(void *) -1)

-   int munmap(void *addr, size_t length)

    -   功能：释放内存映射

    -   参数：

        addr：要释放的内存的首地址

        length：要释放的内存的大小，要和mmap函数中的length参数的值一样

### 注意事项

-   可以对mmap的返回值（ptr）进行++操作，但是不能对++操作后的ptr进行munmap（会错误，要对原ptr地址进行munmap）

-   如果open权限与mmap里的prot权限冲突（比如：open是O_RDONLY，mmap的prot是PROT_READ | PROT_WRITE），则会发生错误，返回一个宏MAP_FAILED

-   如果文件偏移量不是4k的整数会返回MAP_FAILED

-   mmap调用失败的情况

    ​	第二个参数：length = 0

    ​	第三个参数：prot

    ​			只指定了写权限

    ​			与open的权限冲突

-   可以在open的时候通过O_CREAT一个新文件来创建映射区，但是大小不能为0，否则错误（可以通过lseek()或者truncate()对文件进行拓展）

-   mmap后关闭open的文件描述符，对mmap映射没有影响，因为mmap的文件描述符相当于对fd进行了拷贝

-   对ptr越界操作，因为越界操作操作的是非法内存，会导致段错误

### 匿名映射

不需要文件实体的内存映射，只能在父子进程间通信，通过修改mmap中的参数来实现匿名映射

## 信号

### 概念

-   信号是Linux进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
-   发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件：
    -   对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl + C通常会给进程发送一个中断信号
    -   硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令：被0除，或者引用了无法访问的内存区域
    -   系统状态变化。比如alarm定时器到期将硬气SIGALRM信号，进程执行的CPU事件超限，或者该进程的某个子进程退出
    -   运行kill命令或者调用kill函数

### 主要目的

-   让进程知道已经发生了一个特定的事情
-   强迫进程执行它自己代码中的信号处理程序

### 信号的特点

-   简单
-   不能携带大量信息
-   满足某个特定条件才发送
-   优先级比较高

### 查看系统定义的信号

-   kill -l

    前31个信号为常规信号，其余为实时信号

-   信号的5种默认处理动作
    -   Term 终止进程
    -   Ign 当前进程忽略掉这个信号
    -   Core 终止进程，并生成一个Core文件
    -   Stop 暂停当前进程
    -   Cont 继续执行当前被暂停的进程
-   信号的3种状态：产生、未决、递达
-   SIGKILL 和 SIGSTOP信号不能被捕捉、阻塞或者忽略，只能执行默认动作

### 信号集

-   许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为sigset_t
-   在PCB种有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集“。这两个信号集都是内核使用位图机制（二进制）来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中这两个信号集进行修改（事实上只能修改阻塞信号集，未决信号集只读）
-   信号的”未决“是一种状态，指的是从信号的产生到信号被处理前的这一段时间
-   信号的”阻塞“是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生
-   信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作

### 信号相关函数

-   int kill(pid_t pid, int sig)

    -   功能：给某个进程pid，发送某个信号sig

    -   参数：

        ​	pid：需要发送给的进程的id

        ​		> 0：将信号发送给指定的进程

        ​		= 0：将信号发送给当前的进程组

        ​		= -1：将信号发送给每一个有权限接受这个信号的进程

        ​		<-1：这个pid=某个进程组的ID取反

        ​	sig：需要发送的信号的编号或者是宏值（0表示不发送任何信号）

-   int raise(int sig)

    -   功能：给当前进程发送信号

    -   返回值：

        ​	成功：0

        ​	失败：非0

-   void abort(void)

    -   功能：发送SIGABRT信号给当前的进程，杀死当前进程

-   unsigned int alarm(unsigned int seconds)

    -   特点：

        -   非阻塞
        -   与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时

    -   功能：设置定时器（闹钟）。

        ​	函数调用，开始倒计时，当倒计时为0的时候，函数会给当前进程发送一个信号：SIGALARM

    -   参数：

        ​	seconds：倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。取消一个定时器也是通过：alarm(0)

    -   返回值：

        ​	之前没有定时器，返回0	

        ​	之前有定时器，返回之前的定时器剩余的时间

    -   SIGALARM：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器

-   int setitimer(int which, const struct itimerval *new_val, struct itimerval *old_value)

    -   特点：非阻塞的

    -   功能：设置定时器（闹钟）。可以替代alarm函数。精度微秒us，可以实现周期性定时。

    -   参数：

        -   which：定时器以什么时间计时
            -   ITIMER_REAL：真实时间，时间到达，发送SIGALARM	常用
            -   ITIMER_VIRTUAL：用户时间，时间到达，发送SIGVTALRM
            -   ITIMER_PROF：以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送SIGPROF
        -   new_value：设置定时器的属性
        -   old_value：记录上一次定时的时间参数，一般不适用，指定NULL

    -   返回值：

        成功：0

        失败 ：-1	并设置错误号

### 信号捕捉函数

-   sighandler_t signal(int signum, sighandler_t handler)

    typedef void (*sighandler_t)(int) 函数指针

    -   功能：设置某个信号的捕捉行为

    -   参数：

        -   signum：要捕捉的信号

        -   handler：捕捉到信号要如何处理

            ​	SIG_IGN：忽略信号

            ​	SIG_DFL：使用信号默认的行为

            ​	回调函数：这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号

    -   返回值：

        ​	成功：返回上一次注册的信号处理函数的地址。第一次调用返回NULL

        ​	失败：返回SIG_ERR，设置错误号

    -   SIGKILL、SIGSTOP不能被捕捉，不能被忽略

-   int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)

