# 孤独的树

https://ac.nowcoder.com/acm/contest/11225/F

## 题面

给出一棵 n 个点 n−1 条边的树。树的节点为 1~n，节点 i 具有权值 $val[i]$。每次操作选择一个节点 i，再选择 $val[i]$ 的一个**质因子** x，然后令 $val[i]=val[i]\div x$。问：最少操作几次，才能让这棵树变成一棵**孤独的树**。 **孤独的树**的定义：不存在一条边连接的两个节点 u、v，$gcd(val[u],val[v])>1$。

$1\leq n\leq 10^5$

$1\leq val[i]\leq 10^5$

## 做法

由于对于每条边$gcd(val[u], val[v]) = 1$，所以$val[u]$和$val[v]$每个公共质因子p，我们要考虑是$val[u]$删掉还是$val[v]$删掉。显然这是一个树形dp。因此我们将每个质因子从图中抽出来构成新图，然后跑树形dp即可。

## Code

```C++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

signed main() {
    int n; scanf("%d", &n);
    vector<int> a(n);
    int mx = 0;
    for (auto &v: a) {
        scanf("%d", &v);
        mx = max(mx, v);
    }
    vector<int> pri;
    vector<bool> np(mx + 1, 0);
    vector<int> fp(mx + 1, 0);
    for (int i = 2; i <= mx; i++) {
        if (!np[i]) {
            pri.push_back(i);
            fp[i] = i;
        }
        for (int j = 0, sz = pri.size(); j < sz && i * pri[j] <= mx; j++) {
            np[i * pri[j]] = 1;
            if (!fp[i * pri[j]]) fp[i * pri[j]] = pri[j];
            if (i % pri[j] == 0) break;
        }
    }
    vector<vector<int>> rt(mx + 1);
    for (int i = 0; i < n; i++) {
        int v = a[i];
        for (int x = v; x > 1; x /= fp[x]) {
            rt[fp[x]].push_back(i + 1);
        }
    }
    vector<vector<int>> G(n + 1);
    for (int i = 1; i < n; i++) {
        int u, v; scanf("%d%d", &u, &v);
        G[u].push_back(v);
        G[v].push_back(u);
    }
    vector<bool> vis(n + 1, 0);
    vector<vector<int>> f(2, vector<int>(n + 1));
    function<void(int, int, int)> dfs = [&](int x, int fa, int p) {
        vis[x] = 1;
        int c = 0;
        for (int u = a[x - 1]; u > 1 && u % p == 0; u /= p) c++;
        f[1][x] = c; f[0][x] = 0;
        for (auto &v: G[x]) {
            if (vis[v] || v == fa) continue;
            dfs(v, x, p);
            f[1][x] += min(f[1][v], f[0][v]);
            f[0][x] += f[1][v];
        }
    };
    int ans = 0;
    for (auto &p: pri) {
        for (auto u: rt[p]) {
            vis[u] = 0; f[0][u] = f[1][u] = 0;
        }
        for (auto u: rt[p]) {
            if (!vis[u]) {
                dfs(u, 0, p);
                ans += min(f[0][u], f[1][u]);
            }
        }
    }
    printf("%d\n", ans);
}
```

