# 欧拉路

## 定义

$$
\\ 如果图G中的一个路径包括每条边恰好一次,则该路径称为欧拉路径
\\ 如果一个回路是欧拉路径,则称为欧拉回路,即:闭合的欧拉
\\ 欧拉图:具有欧拉回路的图
\\ 半欧拉图:具有欧拉路径不具有欧拉回路的图
$$

## 判断欧拉路

$$
\\ 一个无向图存在欧拉路的充要条件:
\\ 有且仅有两个点,与其相连的边数为奇数,其他点相连边数皆为偶数;或所有点皆为偶数边数
\\ 一个有向图存在欧拉路的充要条件:
\\ 除去起点的终点,所有点的出度与入读相等.起点出度比入度大1,终点入度比出度大1;或所有点出入度相同
$$



## 判断欧拉回路

$$
\\\begin{align}
\\& 无向图存在欧拉回路的充要条件:
\\& 一个无向图存在欧拉回路,当且仅当该图所有顶点度数都是偶数,且改图是连通图
\\& 有向图存在欧拉回路的充要条件:
\\& 一个有向图存在欧拉回路,所有顶点的入度等于出度且该图是连通图
\\& 混合图存在欧拉回路的条件:
\\& 要判断一个混合图G(V,E)(既有有向边又有无向边)是欧拉图，方法如下：
\\& 假设有一张图有向图G'，在不论方向的情况下它与G同构。并且G'包含了G的所有有向边。那么如果存在一个图G'使得G'存在欧拉回路，那么G就存在欧拉回路。
\\& 其思路就将混合图转换成有向图判断。实现的时候，我们使用网络流的模型。
\\& 现任意构造一个G'。用Ii表示第i个点的入度，Oi表示第i个点的出度。
\\& 如果存在一个点k，|Ok-Ik|mod 2=1，那么G不存在欧拉回路。
\\& 接下来则对于所有Ii>Oi的点从源点连到i一条容量为(Ii-Oi)/2的边，对于所有Ii<Oi的点从i连到汇点一条容量为(Oi-Ii)/2的边。
\\& 如果对于节点U和V，无向边（U，V）∈E，那么U和V之间互相建立容量为1的边。如果此网络的最大流等于∑|Ii-Oi|/2，那么就存在欧拉回路。
\\ \end{align}
$$

## 求欧拉路

### Hierholzer(希尔霍尔策)

```C++
#include<bits/stdc++.h>
using namespace std;
const int N = 5 + 1e5;
vector<int> G[N];
int out[N], in[N];
int cnt, pt[N];//手写栈
void dfs(int x) {
    for (; !G[x].empty(); ) {
        auto u = G[x].back(); G[x].pop_back();
        dfs(u);
    }
    pt[++cnt] = x;
}
signed main() {
    int n, m; cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int u, v; cin >> u >> v;
        G[u].push_back(v);
        out[u]++; in[v]++;
    }
    bool f = 0;
    for (int i = 1; i <= n; i++) {
        if (out[i] - in[i] == 1) {
            f = 1;
            dfs(i);
            break;
        }
    }
    if (!f) dfs(1);
    for (int i = cnt; i >= 1; i--) {	//出栈(路径)
        
    }
}
```



### Fleury(佛罗莱)
