#	出圈游戏

一个圈n个人，按顺序编号1~n，指定m，从编号1开始顺序报数，每第m个出圈，然后重新报数，直到最后一个人，输出最后一个人的编号 
输入：
一行两个正整数，中间有一个空格，分别是n,m
输出：
一行一个正整数，表示最后一个出圈的编号	 
小样例：
10 3 
4 

## 分析

1.因为是圈，所以当m积累到超过n的时候会从圈头开始,即：
每次经过的数都补到当前的数列的尾部，那么我们可以知道，数列每次向前移动m位，并把前m位放到后面 
2.因为圈的大小固定，每次的m也是固定的，所以显而易见答案对应的人在过程中是独立的，即：
不受其他人影响，所以我们可以只追踪答案的位置变化	 
模拟一波小样例：
							答案位置：	
1 2 -3 4 5 6 7 8 9 10	4 
4 5 -6 7 8 9 10 1 2		1 
7 8 -9 10 1 2 4 5 		7 
10 1 -2 4 5 7 8			4 
4 5 -7 8 10 1			1 
8 10 -1 4 5				4 
4 5 -8 10				1 
10 4 -5					2 
-10 4					2 
-4						1		  	 
构造法：
通过小样例我们发现：
每次(层)减少一个,对于要剩下k个，只需要将剩下k+1时候的数列，向前移动m-1个，去掉第m个，并在背后补齐，然后取前k个，由于我们只关注最后剩下一个的位置，所以我们就得到关于答案位置变化的一个递推公式:
s(k)=(f(s(k+1)-m))%k
s(k+1)-m>0 s(k+1)-m
s(k+1)-m<0 k+1-m+s(k+1)
s	p
10	4
9	1
8	7
7	4
6	1
5	4
4	1
3	2
2	2
1	1
因为，我们一开始不知道答案的编号，即：不知道答案的位置，但是我们显然知道答案最后的位置是1。所以，又因为这个过程显然是可逆的，因此我们采取逆推，即：
当前剩余k个的答案的位置，由剩余k-1时的位置向后退m格,然后取后k个，
这里由于我们只考虑答案的位置，所以其他新加入的对应的编号是多少我们并不在意，只要知道多了一个就行
递推公式:
s(k)=(s(k-1)+m)%k
k	p
1	1
2	2
3	2
4	1 
5	4
6	1
7	4	
8	7
9	1
10	4
另外我们注意到，为了间接的描述取最后k个数，我们使用了模运算%，但是他是从0开始的，所以我们要令我们的位置也从0开始，并在最后+1			 

## 代码

#include<iostream>
using namespace std;
int main(){
	int n,m,s=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		s=(s+m)%i;
	cout<<s+1<<endl;	
}