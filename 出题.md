# 出题

## https://codeforces.com/contest/1609/problem/C

$$
\\ 数论、筛
\\ 加强数据
$$

### 题意

$$
\\ 给定n,e和数组\{a\},求满足下列条件的(i, k)有多少对:
\\ 1\leq i,k
\\ i + ek\leq n
\\ \prod_{j=0}^k a_{i+je}\in prime
$$

### 做法 O(n)

$$
\\ 显然\forall 0\leq j\leq k, i+je是一个等差数列
\\ 因此我们可以把他们分别抽出来,并用不同的起始项[0,k-1]来区分他们
\\ 考虑一个等差数列对答案的贡献,要满足条件3,那么形式应该是:
\\ \underbrace{1\ 1\dots1\ }_{l} P\underbrace{1\ 1\dots 1}_{r}
\\ 则其贡献为(l+1)(r+1)-1
$$

### Code

```C++
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
#define LL __int128
using namespace std;
int qpow(int a, int b, int p) {int ret = 1; for(a %= p; b; b >>= 1, a = a * a % p) if(b & 1) ret = ret * a % p; return ret; }
int qpow(int a,int b) {int ret = 1; for(; b; b >>= 1, a *= a) if(b & 1) ret *= a; return ret; }
int gcd(int x,int y) {return y ? gcd(y, x % y) : x; }
pair<int,int> exgcd(int a,int b) { if(!b) return {1, 0}; pair<int,int> ret = exgcd(b, a % b); return {ret.second, ret.first - a / b * ret.second }; }
int lcm(int x,int y){ return x / gcd(x, y) * y; }
const int mod = 7 + 1e9;
const int N = 5 + 1e7;
bool np[N];
int tot, pri[N];
int a[N];
bool hp[N];
int l[N], r[N];
signed main() {
    for (int i = 2; i < N; i++) {
        if (!np[i]) { pri[++tot] = i; }
        for (int j = 1; j <= tot && i * pri[j] < N; j++) {
            np[i * pri[j]] = 1;
            if (i % pri[j] == 0) break;
        }
    }    
    int _; cin >> _;
    while (_--) {
        int n, k; cin >> n >> k;
        for (int i = 0; i <= k; i++) {
            l[i] = r[i] = 0;
            hp[i] = 0;
        }
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            cin >> a[i];
            int v = i - (i / k) * k;
            if (a[i] == 1) {
                if (!hp[v]) l[v]++;
                else r[v]++;
            } else if (np[a[i]]) {
                if (!hp[v]) {
                    l[v] = 0, r[v] = 0;
                } else {
                    ans += l[v] * (r[v] + 1) + r[v];
                    l[v] = r[v] = 0;
                    hp[v] = 0;
                }
            } else {
                if (!hp[v]) {
                    hp[v] = 1;
                } else {
                    ans += l[v] * (r[v] + 1) + r[v];
                    l[v] = r[v]; r[v] = 0;
                }
            }
        }
        for (int i = 0; i < k; i++) {
            if (hp[i]) {
                ans += l[i] * (r[i] + 1) + r[i];
            }
        }
        cout << ans << endl;
    }
}
```

## https://codeforces.com/contest/1609/problem/D
$$
\\ 并查集
\\ 加强数据
$$

### 题意

$$

$$

## 做法 O(qlgn)

$$
\\ 在线维护一个当前答案集(优先合并对象)和一个可选答案集(可选合并对象) 
\\ 考虑每次合并时对集的影响和对答案贡献的更改
\\ 用set<sz[i],i>来维护
$$

### Code

```C++

```

