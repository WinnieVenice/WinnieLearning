# 矩形周长并

https://www.luogu.com.cn/problem/P1856

## 题面

二维坐标系上给定n个矩形，求所有矩形合并后的周长

## 输入

第一行一个n

接下来n行，每行两个点表示一个矩形，分别是左下点和右上点，每个点有两个整数，分别表示x，y

## 做法

扫描线

特别注意，当高度一样时候

```C++
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace discrete {
    #define T int
    vector<T> a;
    int n;
    void init(T inf) { a.clear(); a.emplace_back(-inf); a.emplace_back(inf); }
    void add(T x) { a.emplace_back(x); }
    void work() {
        sort(a.begin(), a.end());
        n = unique(a.begin(), a.end()) - a.begin();
    }
    void era() { a.erase(a.begin() + n, a.end()); }
    int get(T x, int y) {
        int u = 0;
        if (y == 0) { // 找第一个a_i <= x
            u = upper_bound(a.begin(), a.begin() + n, x) - a.begin();
            u--;
        } else if (y == 1) { // 找第一个a_i >= x
            u = lower_bound(a.begin(), a.begin() + n, x) - a.begin();
        } else if (y == 2) { // 找第一个a_i > x
            u = upper_bound(a.begin(), a.begin() + n, x) - a.begin();
        } else { //找第一个a_i < x
            u = lower_bound(a.begin(), a.end(), x) - a.begin();
            u++;
        }
        return u;
    }
    #undef T
}
struct T {
    int l, r, w, v;
};
const int N = 5 + 5e3;
vector<T> li;
int len[N << 2], sum[N << 2], cnt[N << 2], lt[N << 2], rt[N << 2];
void poll(int x, int l, int r) {
    if (sum[x]) {
        len[x] = discrete::a[r + 1] - discrete::a[l];
        cnt[x] = 1;
        lt[x] = rt[x] = 1;
    } else if (l < r) {
        lt[x] = lt[x << 1]; rt[x] = rt[x << 1 | 1];
        len[x] = len[x << 1] + len[x << 1| 1];
        cnt[x] = cnt[x << 1] + cnt[x << 1| 1];
        if (rt[x << 1] && lt[x << 1| 1]) {
            cnt[x]--;
        }
    } else {
        len[x] = 0; cnt[x] = 0; lt[x] = 0; rt[x] = 0;
    }
}
void upd(int x, int l, int r, int L, int R, int v) {
    if (l > R || r < L) return;
    if (L <= l && r <= R) {
        sum[x] += v; lt[x] += v; rt[x] += v;
        poll(x, l, r);
        return;
    }
    int mid = l + r >> 1;
    upd(x << 1, l, mid, L, R, v); upd(x << 1| 1, mid + 1, r, L, R, v);
    poll(x, l, r);
}
signed main() {
    int n; cin >> n;
    discrete::init(2e9);
    for (int i = 0; i < n; i++) {
        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;
        discrete::add(x1);
        discrete::add(x2);
        li.push_back({x1, x2, y1, 1});
        li.push_back({x1, x2, y2, -1});
    }
    discrete::work();
    sort(li.begin(), li.end(), [&](T x, T y) {
        return x.w < y.w || x.w == y.w && x.v > y.v; // 高度相同时，先加后减 
    });
    int ans = 0, pre_len = 0;
    for (int i = 0, sz = n << 1; i < sz; i++) {
        upd(1, 1, discrete::n, discrete::get(li[i].l, 1), discrete::get(li[i].r, 1) - 1,  li[i].v);
        for (; i + 1 < sz && li[i + 1].w == li[i].w && li[i + 1].v == li[i].v; ++i) {
            upd(1, 1, discrete::n, discrete::get(li[i + 1].l, 1), discrete::get(li[i + 1].r, 1) - 1, li[i + 1].v);
        } 
        ans += 2 * cnt[1] * (li[i + 1].w - li[i].w); //y
            ans += abs(len[1] - pre_len);//x
            pre_len = len[1];
        }
        cout << ans << '\n';    
}

```

事实上，如果分别对x和y做一次的话不容易出bug