# 窗口的星星

https://www.luogu.com.cn/problem/P1502

## 题面

二维平面给定n个点$(x_i,y_i)$和其权值$w_i$。现在你有一个宽为W，长为H的方框，问你如何放置方框使得方框框住的点的权值和最大（方框边上的不算框住的）

## 做法

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace discrete {
    #define T int
    vector<T> a;
    int n;
    void init(T inf) { a.clear(); a.emplace_back(-inf); a.emplace_back(inf); }
    void add(T x) { a.emplace_back(x); }
    void work() {
        sort(a.begin(), a.end());
        n = unique(a.begin(), a.end()) - a.begin();
    }
    void era() { a.erase(a.begin() + n, a.end()); }
    int get(T x, int y) {
        int u = 0;
        if (y == 0) { // 找第一个a_i <= x
            u = upper_bound(a.begin(), a.begin() + n, x) - a.begin();
            u--;
        } else if (y == 1) { // 找第一个a_i >= x
            u = lower_bound(a.begin(), a.begin() + n, x) - a.begin();
        } else if (y == 2) { // 找第一个a_i > x
            u = upper_bound(a.begin(), a.begin() + n, x) - a.begin();
        } else { //找第一个a_i < x
            u = lower_bound(a.begin(), a.end(), x) - a.begin();
            u++;
        }
        return u;
    }
    #undef T
}
struct T {
    int l, r, w, v;
};

const int N = 5 + 2e4;
vector<T> li;
int st[N << 2], tag[N << 2];
void init(int x, int l, int r) {
    st[x] = tag[x] = 0;
    if (l == r) {
        return;
    }
    int mid = l + r >> 1;
    init(x << 1, l, mid); init(x << 1| 1, mid + 1, r);
    
}
void poll(int x, int l, int r) {
    st[x] = max(st[x << 1], st[x << 1| 1]);
}
void push(int x) {
    st[x << 1] += tag[x];
    st[x << 1| 1] += tag[x];
    tag[x << 1] += tag[x];
    tag[x << 1| 1] += tag[x];
    tag[x] = 0;
}
void upd(int x, int l, int r, int L, int R, int v) {
    if (l > R || r < L) return;
    if (L <= l && r <= R) {
        st[x] += v; 
        tag[x] += v;
        return;
    }
    push(x);
    int mid = l + r >> 1;
    upd(x << 1, l, mid, L, R, v); upd(x << 1| 1, mid + 1, r, L, R, v);
    poll(x, l, r);
}
signed main() {
    int _; cin >> _;
    for (; _--; ) {
        int n, W, H; cin >> n >> W >> H;
        discrete::init(1e18);
        li.clear();
        for (int i = 0; i < n; i++) {
            int x, y, l; cin >> x >> y >> l;
            // (x, y) (x + W - 1, y + H - 1)
            discrete::add(x); discrete::add(x + W - 1);
            li.push_back({x, x + W - 1, y, l});
            li.push_back({x, x + W - 1, y + H - 1, -l});
        }
        discrete::work();
        sort(li.begin(), li.end(), [&](auto x, auto y) {
            return x.w < y.w || x.w == y.w && x.v > y.v;
        });
        init(1, 1, discrete::n);
        int ans = 0;
        for (int i = 0, sz = n << 1; i < sz; i++) {
            upd(1, 1, discrete::n, discrete::get(li[i].l, 1), discrete::get(li[i].r, 1), li[i].v);
            ans = max(ans, st[1]);
        }
        cout << ans << '\n';
    }
}
```

