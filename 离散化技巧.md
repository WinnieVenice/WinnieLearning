# 离散化

用map进行离散化常数会大，但是比较方便

用数组进行离散化好一点，有一个trick。将要离散化的数组$\{a_i\}$放在离散化数组$\{b_i\}$的[1, n]上，将一个极小值-inf放在$b_0$,将一个极大值inf放在$b_{n+1}$上。这样，当在$\{a_i\}$上找不到符合条件的元素后会返回0或者n+1。只需要将统计贡献部分时对0和n+1的贡献变成无贡献就行。	

```C++
namespace discrete {
    #define T int
    vector<T> a;
    int n;
    void init(T inf) { a.clear(); a.emplace_back(-inf); a.emplace_back(inf); }
    void add(T x) { a.emplace_back(x); }
    void work() {
        sort(a.begin(), a.end());
        n = unique(a.begin(), a.end()) - a.begin();
    }
    void era() { a.erase(a.begin() + n, a.end()); }
    int get(T x, int y) {
        int u = 0;
        if (y == 0) { // 找第一个a_i <= x
            u = upper_bound(a.begin(), a.begin() + n, x) - a.begin();
            u--;
        } else if (y == 1) { // 找第一个a_i >= x
            u = lower_bound(a.begin(), a.begin() + n, x) - a.begin();
        } else if (y == 2) { // 找第一个a_i > x
            u = upper_bound(a.begin(), a.begin() + n, x) - a.begin();
        } else { //找第一个a_i < x
            u = lower_bound(a.begin(), a.end(), x) - a.begin();
            u++;
        }
        return u;
    }
    #undef T
}
```

## 鸿爷的板子

```C++
namespace discrete {
    #define my_type int
    int tot;
    vector<my_type> a(1, 0);
    void init() { a.clear(); a.emplace_back(0); }
    void add(my_type x) { a.emplace_back(x); }
    void work() {
        sort(a.begin() + 1, a.end());
        tot = unique(a.begin() + 1, a.end()) - a.begin();
    }
   	int get(my_type x) { return lower_bound(a.begin() + 1, a.begin() + tot, x} - a.begin(); }
    #undef my_type
}
```

