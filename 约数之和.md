约数之和

## 题面

给定正整数n，记$\sigma_2$为所有约数的平方和，即：$\sigma_2(n)=\sum_{d|n}d^2 $

现在给定整数N和K，其中$1\leq n\leq N$，有些n满足$\sigma_2(n)$和其最接近的完全平方数相差最大不超过K，求所有满足条件的n的和。

## 输入

输入第一行是一个整数q，表示有q次询问

接下来有q行，每行包含两个整数，即N和K

其中$1\leq q\leq 10^5,1\leq N\leq 10^6,0\leq K\leq 10^5$

## 做法

预处理先把$10^6$的函数筛出来，然后把平方数也算出来，在平方数里二分出每个数的最小满足的$k_{min}$，则对于所有$K\geq k$，当前数都有贡献。然后离线处理N，从小到大。对k开个线段树统计贡献。

更简单的用主席树

## Code

```C++
#include<bits/stdc++.h>
#define int long long
const int M = 5 + 1e5;
int st[M << 2], tag[M << 2];
void push(int x, int l, int r) {
    if (tag[x]) {
        int v = tag[x]; tag[x] = 0;
        int mid = l + r >> 1;
        st[x << 1] += (mid - l + 1) * v; tag[x << 1] += v; 
        st[x << 1| 1] += (r - (mid + 1) + 1) * v;   tag[x << 1| 1] += v;
    }
}
void upd(int x, int l, int r, int L, int R) {
    if (l > R || r < L) return;
    if (L <= l && r <= R) {
        st[x] += r - l + 1;
        tag[x]++;
        return;
    }
    push(x, l, r);
    int mid = l + r >> 1;
    upd(x << 1, l, mid, L, R); upd(x << 1| 1, mid + 1, r, L, R);
    st[x] = st[x << 1] + st[x << 1| 1];
}
int que(int x, int l, int r, int L, int R) {
    if (l > R || r < L) return 0;
    if (L <= l && r <= R) return st[x];
    int mid = l + r >> 1;
    push(x, l, r);
    return que(x << 1, l, mid, L, R) + que(x << 1| 1, mid + 1, r, L, R);
}
signed main() {
    const int N = 5 + 1e6;
    std::vector<int> d1(N, 1), d2(N, 1);
    for (int i = 2; i < N; i++) {
        for (int j = i; j < N; j += i) {
            d1[j] += i; d2[j] += i * i;
        }
    }
    for (int i = 2; i < N; i++) {
        d1[i] += d1[i - 1];
    }
    std::vector<int> K(N);
    for (int i = 1; i < N; i++) {
        auto x = std::lower_bound(d1.begin(), d1.end(), d2[i]) - d1.begin();
        //std::cout << i << ' ' << d1[x] - d2[i] << ' ' << ( x ? d2[i] - d1[x - 1]: (int)1e9) << '\n';
        K[i] = std::min({d1[x] - d2[i], x ? d2[i] - d1[x - 1]: (int)1e9});
    }
    int m; std::cin >> m;
    std::vector<std::tuple<int, int, int>> q(m);
    for (int i = 0; i < m; i++) {
        int n, k; std::cin >> n >> k;
        q.push_back({n, k, i});
    }
    std::sort(q.begin(), q.end(), [&](auto x, auto y) {
        auto [x1, x2, x3] = x;
        auto [y1, y2, y3] = y;
        return x1 < y1;
    });
    int pre = 0;
    std::vector<int> ans(m);
    int mx = 0;
    for (auto [n, k, i]: q) {
        mx = std::max(mx, n);
        for (; pre < n; pre++) {
            upd(1, 0, M - 1, K[pre + 1], K[pre + 1]);
        }
        ans[i] = que(1, 0, M - 1, 0, k);
    }
    for (int i = 0; i < m; i++) {
        std::cout << ans[i] << '\n';
    }
    //for (int i = 1; i <= mx; i++) std::cout << d2[i] << ' '; std::cout << '\n';
    //for (int i = 1; i <= mx; i++) std::cout << d1[i] << ' '; std::cout << '\n';
    //for (int i = 1; i <= mx; i++) std::cout << i << ' ' << K[i] << '\n';
}
```

